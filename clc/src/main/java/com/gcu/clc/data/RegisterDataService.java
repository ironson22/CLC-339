package com.gcu.clc.data;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.Statement;


import javax.sql.DataSource;

import com.gcu.clc.model.RegistrationModel;
import com.gcu.clc.model.UserModel;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.jdbc.support.rowset.SqlRowSet;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Service;
@Service
public class RegisterDataService {
    @Autowired
    private DataSource dataSource;

    private JdbcTemplate jdbcTemplateObject;

    public RegisterDataService(DataSource dataSource){
        this.dataSource = dataSource;
        this.jdbcTemplateObject = new JdbcTemplate(dataSource);
    }

    
    /** 
     * Creates a user and puts it into the database
     * @param user
     * @return UserModel
     */
    //https://www.baeldung.com/spring-jdbc-autogenerated-keys    
    
    public UserModel createUser(RegistrationModel user){
        String sql = "INSERT INTO users(fname, lname, password, phone_number, email, address) VALUES (?, ?, ?, ?, ?, ?)";
        //Encrpytions the password before sending it to the database
        String encryptedPassword = new BCryptPasswordEncoder().encode(user.getPassword());
        try{
            //Checks if an email has already been used, if so it returns a user model with a -1 index
            if(findDuplicateEmail(user.getEmail())){
                return new UserModel(-1L, "", "", "", "", "", "", "");
            }
            //Used to get the primary key after creating the object to instantiate a new UserModel object
            KeyHolder keyHolder = new GeneratedKeyHolder();
            //Uses the JdbcTemplate to send a query to create a user
            int rows = jdbcTemplateObject.update(connection ->{
                //A prepared statement that uses the SQL statement defined above, and also says that there be a key returned (the primary key created when the user is created)
                PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
                //Sets each value being sent in the sql statement
                ps.setString(1, user.getFirstName());
                ps.setString(2, user.getLastName());
                ps.setString(3, encryptedPassword);
                ps.setString(4, user.getPhoneNumber());
                ps.setString(5, user.getEmail());
                ps.setString(6, user.getAddress());
                return ps;
            }, keyHolder);
            //If there was a row that was effected (the one that was made) then a new user will be made and returned. Otherwise, a null value is returned
            if(rows == 1){
                UserModel newUser = new UserModel(keyHolder.getKey().longValue(), user.getFirstName(), user.getLastName(), user.getPassword(), user.getPhoneNumber(), user.getEmail(), "", user.getAddress());
                return newUser;
            }else{
                return null;
            }
        }catch(Exception e){
            e.printStackTrace();
            return null;
        }
    }

    
    /** 
     * Checks if an email has already been used
     * @param email
     * @return boolean
     */
    public boolean findDuplicateEmail(String email){
        //SQL statement that checks for a specific email
        String sql = "SELECT email FROM eBuy.users WHERE email = '" + email +"'";
        SqlRowSet results = jdbcTemplateObject.queryForRowSet(sql);
        //Checks for results
        if(results.last()){
            return true;
        }else{
            return false;
        }
    }
}
